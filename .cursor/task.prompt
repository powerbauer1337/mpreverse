
# ğŸ” MarsPro-App Reverse Engineering & Home Assistant Integration (Cursor Prompt)

## ğŸ¯ Ziel
Reverse-engineere die Android-App â€MarsProâ€œ, extrahiere alle relevanten REST- und BLE-Endpunkte und implementiere eine Home Assistant Integration zur lokalen Steuerung von Lampen und Ventilatoren â€“ ohne Cloud.

Arbeite dabei vollstÃ¤ndig innerhalb von **Cursor unter Ubuntu 24**, verwende **MCP-Tools**, **Frida**, und automatisiere alles inkl. Dokumentation, Code und Tests.

---

## ğŸ§° Vorbereitungen (einmalig)

1. Installiere systemweit:
   ```bash
   sudo apt update && sudo apt install openjdk-17-jdk python3 python3-pip adb unzip curl
   pip install frida-tools uv
   ```

2. Installiere und konfiguriere MCP-Tools in Cursor:
   - `apktool-mcp-server` (mit `uv`)
   - `jadx-ai-mcp`
   - Lege `.cursor/mcp.json` an mit Pfaden zu den MCP-Servern
   - Teste mit: `cursor mcp list`

3. Lege Projektstruktur an:
   ```
   MarsProAnalysis/
   â”œâ”€â”€ MarsPro.apk
   â”œâ”€â”€ .cursor/mcp.json
   â”œâ”€â”€ scripts/
   â”œâ”€â”€ docs/
   â”œâ”€â”€ configuration_samples/
   â””â”€â”€ custom_components/marspro/
   ```

---

## ğŸ” Phase 1: APK statisch analysieren

1. Dekompiliere die APK:
   ```bash
   apktool d MarsPro.apk -o MarsPro_apktool
   jadx -d MarsPro_jadx_out MarsPro.apk
   ```

2. Verwende MCP-Tools Ã¼ber Cursor-Chat:
   - `get_android_manifest()`
   - `get_all_classes()`
   - `search_in_file("http")`
   - `get_class_source("com.marspro.MainActivity")`

3. Dokumentiere:
   - Berechtigungen aus Manifest
   - REST-Endpunkte und Parameter
   - BLE-Service-/Charakteristik-UUIDs
   - Authentifizierungsmechanismen

---

## ğŸ§ª Phase 2: Dynamische Analyse mit Frida

1. Starte `frida-server` auf einem gerooteten GerÃ¤t:
   ```bash
   adb push frida-server /data/local/tmp/
   adb shell "chmod 755 /data/local/tmp/frida-server && su -c /data/local/tmp/frida-server &"
   ```

2. Lade deine Frida-Hooks (z.â€¯B.):
   - `scripts/net_hook.js`: HTTP-Interception
   - `scripts/ble_hook.js`: BLE-Kommandos & Responses

3. Starte MarsPro unter Frida:
   ```bash
   frida -U -f com.marspro.app -l scripts/net_hook.js --no-pause
   ```

4. Extrahiere:
   - Tokens
   - API-Calls
   - BLE-GATT-Datenverkehr

---

## ğŸ“‘ Phase 3: Dokumentation & Mapping

1. Erstelle folgende Dateien:
   - `docs/analysis.md`: Zusammenfassung statisch + dynamisch
   - `docs/endpoints.md`: Tabellen mit URL, Methode, Payload
   - `docs/api_mapping.md`: Cloud- vs. Local-Funktionen

2. Verwende im Chat:
   - â€Fasse alle API-Endpunkte als Markdown-Tabelle zusammenâ€œ
   - â€Liste alle Funktionen auf, die writeCharacteristic aufrufenâ€œ

---

## âš™ï¸ Phase 4: Komponentencode erstellen

1. Erstelle `api_cloud.py` basierend auf Analyse von `api.py`
2. Implementiere `api_ble.py` (BLE via `bleak`):
   - `connect()`, `send_command()`, `get_status()`

3. Erstelle Home Assistant-Komponenten in:
   ```
   custom_components/marspro/
   â”œâ”€â”€ __init__.py
   â”œâ”€â”€ manifest.json
   â”œâ”€â”€ light.py
   â”œâ”€â”€ fan.py
   â””â”€â”€ sensor.py
   ```

---

## ğŸ§© Phase 5: Home Assistant Integration

1. YAML-Konfigurationsbeispiel:
   ```yaml
   marspro:
     email: user@example.com
     password: mypass
     use_cloud: false
     ble_mac: "A0:B1:C2:D3:E4:F5"
   ```

2. Lege in `configuration_samples/` passende YAML-Snippets ab

3. Generiere `README.md`, `CHANGELOG.md`, `CONTRIBUTING.md` automatisch mit Cursor-Chat

---

## ğŸ§ª Phase 6: Validierung & Tests

1. Testskripte:
   - `scripts/test_rest.py`
   - `scripts/test_ble.py`

2. Automatisch via:
   ```bash
   python3 -m unittest discover -s custom_components/marspro/
   ```

3. Checkliste:
   - GerÃ¤t per BLE steuerbar?
   - Token handling stabil?
   - Konfiguration mit Home Assistant GUI funktioniert?

---

## âœ… Abschluss

1. Cursor-Chat-Prompt:
   - â€Validiere, ob alle Anforderungen aus dem SRD erfÃ¼llt sindâ€œ
2. PrÃ¼fe, ob folgende Dateien existieren:
   - `docs/`, `scripts/`, `custom_components/`
   - `api_cloud.py`, `api_ble.py`
   - YAML-Snippets + MCP konfiguriert
